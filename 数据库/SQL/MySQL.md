# MySQL

MySQL 是一种关系型数据库。开源免费，并且方便扩展。在 Java 企业级开发中非常常用。MySQL 的默认端口号是 3306。

MySQL 主要分为服务层（指挥者）和存储引擎（执行者）两部分，现在最常用的存储引擎是 InnoDB。

---

##  服务层 Server

负责对数据操作的分析、处理和优化，指挥存储引擎进行数据存取。包括连接器、查询缓存、分析器、优化器、执行器等基本组件。

### 连接器

主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作。登录通过后连接器会连接到权限表，并查询该用户的所有权限。后续只要这个连接不断开，即使管理员修改了该用户的权限，用户也不受影响。

### ~~查询缓存~~

缓存 SELECT 语句以及返回的结果。收到查询语句会首先和缓存比对，如果相同就直接从查询缓存里返回数据。

更新表后，这个表上的所有的查询缓存都会被清空。这导致实际使用场景中查询缓存的作用非常少，在 MySQL 8.0 版本后移除。

### 分析器

如果查询语句未命中缓存，或者是更新语句，那么将由分析器负责分析 SQL 语句的用途。

1. 词法分析：提取关键字，提取 SQL 语句的关键元素，明确 SQL 语句的功能。

2. 语法分析：判断 SQL 语句是否正确，是否符合 MySQL 的语法。如果不符合语法则返回错误信息。

###  优化器

明确 SQL 语句功能后，由优化器选择尽可能最优的执行方案。比如多个索引的时候选择索引，多表查询的时候选择关联顺序。

### 执行器

确定执行方案后，校验该用户有没有权限。权限无误后交由存储引擎执行语句，然后从存储引擎返回数据。

---

## 存储引擎

负责实际执行对数据库数据的存取。目前 MySQL 默认使用 InnoDB 引擎。相比于过去使用 MyISAM 引擎，有以下几个优势：

1. 支持外键。
2. 支持行级锁，提高并发度。
3. 支持事务；添加本地日志，发生故障重启后能够安全恢复数据。
4. 支持多版本并发控制 MVCC ，高并发下性能更好。



### 索引 & 视图

#### 索引

MySQL 数据库中使用 **B+ 树和哈希表**这两种数据结构来存储和查找数据。哈希表适用于查询单条数据，B+ 树适用于连续查询多条数据。

MyISAM 引擎中索引文件和数据文件是分离的，而 InnoDB 存储引擎数据文件本身就是索引文件：表数据文件本身是主索引，其余的索引作为辅助索引。

*辅助索引中记录了主键的值而不是字段地址。根据辅助索引查找时，仍需要根据主键的值在主索引中查询。 因此不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键。*


#### 视图

视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。

视图具有表结构文件，但不存在数据文件。
    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。
    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。

#### 外键

*不推荐使用。*

### 事务 & 锁

事务是逻辑上的一组操作，要么都执行，要么都不执行。保障数据之间的同步。

#### 事务的特性 ACID

- 原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
- 一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
- 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
- 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

#### 并发事务可能带来的问题

**丢失修改**

事务（T1）修改数据的过程中，另一个并发事务（T2）也修改了该数据。导致事务（T1）对数据的修改丢失。

**脏读**

事务（T1）修改数据但还未写入数据库时，另一个并发事务（T2）使用了该数据。导致事务（T2）读取数据可能是不正确的。

**不可重复读**

事务（T1）两次读取数据的过程中，另一个并发事务（T2）修改了部分数据。导致事务（T1）两次读取数据的结果不同。

**幻读**

事务（T1）两次读取数据的过程中，另一个并发事务（T2）插入或删除了部分数据。导致事务（T1）两次读取数据的结果不同。

#### 事务隔离级别

- **READ-UNCOMMITTED(RU) 读取未提交** 

事务进行读操作时允许其他事务访问，事务进行写操作将会禁止其他事务写。

- **READ-COMMITTED(RC) 读取已提交**

事务进行读操作时允许其他事务访问，事务进行写操作将会禁止其他事务读写。

- **REPEATABLE-READ(RR) 可重复读**

事务进行读操作时会禁止其他事务写，事务进行写操作将会禁止其他事务读写。

- **SERIALIZABLE 可串行化**

事务进行读写操作时，都会禁止其他事务读写。

隔离级别 | 丢失修改 | 脏读 |  不可重复读 |幻读
-|-|-|-|-
READ-UNCOMMITTED|×|√|√|√
READ-COMMITTED|×|×|√|√
REPEATABLE-READ|×|×|×|√
SERIALIZABLE|×|×|×|×

MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ(RR) ，且 InnoDB 存储引擎在该事务隔离级别下使用 Next-Key Lock 锁算法，因此可以避免幻读的产生。InnoDB 存储引擎在分布式事务情况下一般会用到 SERIALIZABLE 隔离级别。

#### 数据锁

存储引擎通过给数据加锁来保障事务性。MyISAM 引擎只支持表级锁，而 InnoDB 存储引擎支持行级锁和表级锁，默认为行级锁。

- 表级锁：对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。但触发锁冲突的概率最高，并发度低。
- 行级锁：只针对当前操作的数据行加锁。大大减少数据库操作的冲突，并发度高。但加锁的开销也最大，可能会出现死锁。

### 日志 & 安全恢复

当数据库数据发生更改时，用日志记录数据库操作。当发生错误或者冲突时，可以进行回滚。保证数据的一致性。

#### bin log 归档日志

最开始 MySQL 并没与 InnoDB 引擎，其他存储引擎只有通用的 bin 日志用来归档（位于 server 层）。

InnoDB 引擎完成主存数据更新后向执行器提交，由 bin 日志记录操作。如果主存数据已更新，且 bin 日志没有被写入时数据库崩溃，后续进行机器备份的时候就会丢失原有数据。这导致数据没有安全恢复的能力：一旦数据库发生异常重启，之前提交的记录都会丢失。

#### redolog 重做日志

MySQL 引入 InnoDB 引擎后，自带了 redo 日志。用于数据库发生异常重启时系统记录的恢复。

1. InnoDB 引擎完成主存数据更新但还未提交时，由 redo 日志记录操作并进入 prepare 状态。
2. InnoDB 引擎向执行器提交时，由 bin 日志记录操作。
3. 提交完成后执行器通知 InnoDB 引擎，redo 日志进入 commit 状态。

如果 bin 日志没有被写入时数据库崩溃，后续进行机器备份的时候就会按照 redo 日志恢复数据。

如果 bin 日志已经写完但 redo 日志还处于 prepare 状态时数据库崩溃。MySQL 会判断 redo 日志是否完整，如果完整就立即提交。否则再判断 bin 日志是否完整，如果完整就提交 redo 日志，不完整就回滚事务。这样就解决了数据一致性的问题。

---

## 数据类型

### 字符串类型


常用的字符串类型有定长字符串 CHAR 和变长字符串 VARCHAR 两种，必须用数字注明可容纳的字符数。

- CHAR(n) 表示固定容纳 n 个字符，当少于 n 个字符时，会使用空格填充。
- VARCHAR(n) 表示最多容纳 n 个字符，当少于 n 个字符时不会补空。起始位和结束位需要额外 3 字节。

> 英文字母单个字符占 1 字节。汉字单个字符 UTF-8 编码占 3 字节，GBK 编码占 2 字节。

对于长字符串数据可以用 TEXT 或 BLOB 类型存储，固定占用 65535 字节。其中 TEXT 保存文本格式，BLOB 保存二进制格式。如果需要存储更短或更长的字符串类型数据，可以使用 TEXT/BLOB 的扩充类型：如 TINYTEXT、MEDIUMTEXT 和 LONGTEXT。

类型名称|大小（字节）|数据库类型|JAVA 类型
-|-|-|-	 
CHAR(n)|N(0-255)|CHAR|String		 	 	 	 
VARCHAR(n)|N+3(0-65535)|VARCHAR|String
TEXT|65535|VARCHAR|String	
BLOB|65535|BLOB|byte[]

CHAR 类型最大只能容纳 255 字节数据，已不推荐使用。目前 VARCHAR 支持容纳最大 65535 字节数据，且长度不固定能有效节省数据库空间，推荐尽量使用 VARCHAR 数据类型取代 TEXT。


### 整型 & 浮点型

#### 布尔型

布尔型数据用 BIT 表示。

类型名称|大小（字节）|取值|JAVA 类型
-|-|-|-	 
BIT|1|0 or 1|Boolean

#### 整型

整形数据一般用 INT/INTEGER 表示，固定占用 4 字节。如果需要存储更短或更长的整型数据，可以使用 INT 的扩充类型：如 TINYINT、SMALLTEXT 和 MEDIUMTEXT 和 BIGINT。

在声明整型数据时也可以注明显示位宽，如 int(n)。在整形数据不足 n 位时会自动补零，几乎没有任何用处。

类型名称|大小（字节）|表示范围|JAVA 类型
-|-|-|-	 
TINYINT| 1 |	(-128，127)	(0，255)| Integer
SMALLINT|2 |	(-32 768，32 767)(0，65 535)|	Integer
MEDIUMINT|3 |(-8 388 608，8 388 607)(0，16 777 215)	|Integer
INT/INTEGER|	4 |	(-2 147 483 648，2 147 483 647)	(0，4 294 967 295)|	Integer
BIGINT|	8 |非常大|	BigInteger

#### 浮点型

常用的浮点型数据类型有 FLOAT/DOUBLE ，FLOAT 类型固定占用 4 字节，DOUBLE 类型固定占用 8 字节。但 FLOAT/DOUBLE 只是近似存储，在数据库中我们常用 DECIMAL 类型记录金额，在数据库中实际以字符串形式存储，以确保不会产生任何误差。

- DECIMAL(M,D) M 表示最大位数，D 表示小数点右侧的位数。如 DECIMAL(5,2) ，小数点前 3 位，小数点后 2 位。

类型名称|大小（字节）|表示范围|JAVA 类型
-|-|-|-	 
FLOAT| 4 |	| Float
DOUBLE|8 |	| Double
DECIMAL(M,D)|M + 2 | | BigDecimal	

### 日期类型

java.sql 包内有专用 Java 类型匹配，注意数据类型必须是 java.sql.Date，而不是 java.util.Date 。

类型|大小（字节）|格式|表示范围|JAVA 类型
-|-|-|-|-	
YEAR|1|YYYY|1901/2155|Date
DATE|3|YYYY-MM-DD|1000-01-01/9999-12-31|Date
TIME|3|HH:MM:SS|'-838:59:59'/'838:59:59'|Time
TIMESTAMP|4|YYYY-MM-DD HH:MM:SS| 1970-01-01 00:00:00/2038-1-19 11:14:07|Timestamp
DATETIME|8|YYYY-MM-DD HH:MM:SS|1000-01-01 00:00:00/9999-12-31 23:59:59|Timestamp


### 枚举 & 集合

enum(val1, val2, val3...)
    在已知的值中进行单选。最大数量为65535.
    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。
    表现为字符串类型，存储却是整型。
    NULL值的索引是NULL。
    空字符串错误值的索引值是0。

set(val1, val2, val3...)
    create table tab ( gender set('男', '女', '无') );
    insert into tab values ('男, 女');
    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。
    当创建表时，SET成员值的尾部空格将自动被删除。
