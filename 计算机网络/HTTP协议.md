

# HTTP 协议

应用层协议，负责 WEB 通信。底层通过 TCP 协议实现，默认端口号 80 。

### URL

统一资源定位符，是一种具体的 URI。不仅唯一标识资源，而且还提供了定位该资源的信息。HTTP 协议通过 URL 访问资源。

如 http://localhost:443/student?id=10&name=mrjoker

### 长连接 & 短连接

**HTTP/1.0** 中默认使用短连接：访问页面时，客户端和服务器之间每次 HTTP 操作都会单独使用一次 TCP 连接，传输完毕后自动关闭。

客户端和服务器之间都会建立多个 HTTP 会话，开销较大。

**HTTP/1.1** 起默认使用长连接：访问页面时，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，直到所有 web 资源传输完毕。

长连接会在 HTTP 响应头标注：`Connection:keep-alive`  

### 无状态协议

HTTP 协议是无状态协议，不保存请求和响应之间的通信状态。通信过后，服务器和客户端之间无法相互识别。

#### Session & Cookie

客户端和服务器使用 cookie & session 记录对方信息，用来相互识别。cookie 数据保存在客户端，session 数据保存在服务器端。

1. 客户端初次访问服务器时，服务端会自动创建 session 用来标识用户。然后在响应头 Set-Cookie 项向客户端返回 session ID。

2. 客户端再次访问服务器时，会在请求头 Cookie 项向服务器发送 session ID，服务器根据 ID 查询 Session 就可以识别用户。

cookie 也可以用来保存其他用户信息，但敏感信息不要直接写入 cookie 中，而要将 cookie 信息加密，使用时候发到服务器端解密。如果客户端 cookie 被禁用，就需要利用 URL 重写把 session ID 直接附加在 URL 路径上。

#### Token

token 和 session ID 功能相同，都用来在 HTTP 通信中识别用户，过期刷新。

- session ID 由服务器随机生成，保存在服务器 session 中。再次访问时只需要直接比对，就可以确认客户端身份。

- token 由服务器根据用户 ID 和时间戳经过特定算法生成，服务器不保存。再次访问时服务器需要重新计算并比对，才可以确认客户端身份。

cookie 本身不安全，浏览器中 token 除放在 cookie 外，还可以放到 localStorage 中存储。浏览器发送请求时会自动携带 session ID，但发送 token 需要手动在代码中设置。由于浏览器加载 image 标签中的地址也会发送 session ID，因此使用 token 可以有效防止 CSRF 攻击。

## HTTPS 协议

HTTP 协议使用明文在互联网传送数据，易被不法分子监听和截获。

HTTPS 协议在应用层下方添加了 SSL 层，使用 TLS 协议来加密数据包来传输数据。默认端口 443。

### 加密方式

1. 建立连接后的数据交互采用**对称加密**：加密密钥和解密密钥相同。

2. 建立连接时协商密钥采用**非对称加密**：加密密钥和解密密钥不同，两个密钥互相能解密对方的加密内容。

   服务器会公开一个非对称加密密钥（公钥），并保留一个非对称加密码密钥（私钥）。

### 证书认证

服务器公钥由数字认证机构 CA 统一认证。CA 会用自己的私钥加密服务器公钥和相应信息，生成数字证书。在客户端向 CA 查询时将证书发送给客户端核对。

CA 根证书（包含公钥）存储在用户的浏览器中，访问网址时会自动比对服务器公钥。

1. 客户端向服务器发送信息：请求连接，说明自己支持的加密算法，并给出随机数 A。
2. 服务器向客户端发送信息：同意连接请求，确认合适的加密算法，并给出数字证书和随机数 B。
3. 客户端向 CA 核对数字证书，确认有效后得到服务器公钥。

### 建立连接

4. 客户端向服务器发送公钥加密信息：给出随机数 C。
5. 服务器通过私钥解密信息，对信息 Hash 得到数字签名；然后向客户端发送私钥加密信息：返回数字签名。
6. 客户端通过公钥解密信息，核对数字签名，确认服务器收到随机数 C。

之后双方就可以按照约定的对称加密方法，使用三个随机数生成的密钥进行数据交互。








