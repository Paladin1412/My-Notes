# 集合框架

使用 java 集合框架中的类，需要进行导入： `import java.util.*; `   

---

## Collection 接口

【集合】：组织、储存、查找相似的数据元素，规定增删改查的基本操作。

**子接口**

1. **List 接口**    【列表】规定列表内元素有序     
2. **Queue 接口**   【队列】规定队列内元素链式存储 
3. **Set 接口**     【集】规定集内元素值不可重复

### ArrayList 类

【数组序列】实现了 List 等接口：数组存储（随机访问）、元素有序、动态扩容（1.5倍）、线程不安全。

### LinkedList 类

【链表序列】实现了 List、Queue 等接口：双向链表存储（顺序访问）、元素有序、容量无限。

**List 接口方法**

```java
list.add("data1");              // 添加元素
list.add(0, "data0");           // 插入元素

list.remove(0);                 // 删除元素（按索引）
list.remove("data");            // 删除元素（按内容）

list.set(0, "data2");           // 修改元素

list.get(1);                    // 查找元素（按索引）

list.indexOf("data1");          // 查询索引号：第一个
list.lastIndexOf("data1");      // 查询索引号：最后一个
list.size();                    // 查询列表元素个数

list.contains("data3");         // 判定是否含有元素
list.isEmpty();                 // 判定是否为空
list.equals(list2);             // 判定是否元素相同

list.toString();                // 转化为字符串
list.toArray();                 // 转化为数组

Collections.shuffle(list);      // 随机排序
Collections.reverse(list);      // 颠倒排序
Collections.sort(list);         // 按大小排序

// linkedList 特殊方法

linkedlist.addfirst/addlast();         // 添加首尾元素        
linkedlist.removefirst/removelast();   // 删除首尾元素
linkedlist.getfirst/getlast();         // 查找首尾元素
```

> Java 中含 Stack 类和 Queue 接口，但推荐使用 ArrayDeque【基于数组实现的双端队列】=

### HashSet 类

【散列集】实现了 Set 接口：散列存储（由元素值计算实际存储地址）、元素无序且不可重复、动态扩容，基于 HashMap 类实现。

`key.hashCode();` 

### TreeSet 类

【树集】实现了 Set 接口：树型存储、元素有序、容量无限，基于 TreeMap 类实现。

**Set 接口方法**

```java
set.add("data");              // 添加元素

set.remove("data");           // 删除元素

set.get(1);                   // 查找元素(只适用于有序的 set 接口)

set.contains("data");         // 判定是否含有元素
```

*HashSet 支持 add、remove、contains 方法。但没有 get 方法，获取对象要通过 Iterator 来遍历。*

## Map 接口

【表】储存key-value组合，规定了之间的映射关系。

### HashMap 类

【哈希表】 实现了 Map 接口：散列存储（由key值计算实际存储地址）、key值无序且不可重复、动态扩容，线程不安全。

> 实际需求里一般使用 HashMap 类。线程安全需要使用 HashTable 类或 CorrectHashMap 类。

**动态扩容**

创建 HashMap 对象时，默认初始容量为16，负载因数为0.75。

`HashMap<String,Integer> hashMap = new HashMap<>();`

允许自行设定初始容量和负载因数:

`HashMap<String,Integer> hashMap = new HashMap<>(int inital，float load);`   

1. 当发生哈希冲突时，HashMap 类采用链表保存多个元素（当链表长度大于8时，会将链表自动转化为红黑树）。
2. 当达到负载因数后，HashMap 类会新建一个2倍容量的新数组，然后将当前数组数据复制过去。

### TreeMap 类

【树表】 实现了 Map 接口：树型存储、元素有序、容量无限。

**Map 接口方法**

```java
map.put("key_1",1);               // 添加键值对,已有key则覆盖value
map.putIfAbsent("key_2",2);       // 添加键值对,已有key则不操作

map.remove("key_1");              // 删除键值对（按值）           
map.remove("key_2",2);            // 删除键值对（按键值）


map.get("key_1");                 // 获取值,key不存在返回null
map.getOrDefault("key_2",-1);     // 获取值,key不存在返回默认值


map.containsKey("key_1");         // 判断key是否存在  
map.containsValue(1);             // 判断value是否存在          
```

---

## Iterator 接口

【迭代器】不关心实现集合的内部数据结构，便于实现遍历集合。

**遍历顺序**

1. **List类** 按顺序输出。
2. **TreeSet/TreeMap 类** 在返回数据时按key值大小从小到大排列。
3. **HashSet/HashMap 类** 在返回数据时没有特别的顺序。

*LinkedHashSet/LinkedHashMap 类仍使用哈希存储，但给对象添加引用使数据串联起来，可以按顺序返回数据。*

**遍历方法**

1. 顺序访问

```java
Iterator<Integer> iter = list.iterator();
while(iter.hasNext()){
      int num = iter.next();
      if(num < 0) iter.remove();
}
```
2. 随机访问

```java
for (String str : list) {
      System.out.println(str);
}
```

---

## Comparator 接口

【比较器】比较两个元素的大小 `compare(s1, s2);` 

等同于 Comparable 接口的 `s1.compareTo(s2);`  

- 如果参数s1等于s2，则返回0；
- 如果s1小于s2，则返回小于0的值；
- 如果s1大于s2，则返回大于0的值。

**排序算法**

`Arrays.sort(array);`   对数组增序排列(重写compare方法可以实现降序排列)           

`Collections.sort(list);`  对集合元素排列(重写compare方法可以自定义排列顺序)

```java
// 按ID升序排列学生信息

Collections.sort(stus,new Comparator<Student>() {          
    @Override
    public int compare(Student s1, Student s2) {
	    int flag;
	    flag = s1.getID()-s2.getID();
	    return flag;
    }			
});
```
