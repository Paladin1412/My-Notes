# 虚拟机

<br>

- **JDK（开发工具包）** 能够创建和运行 Java 程序。包含各种 Java 工具和基础类库。

    - **JRE（运行环境）** 能够运行已编译的 Java 程序。包含 JVM 执行的必要基础类库。

        - **JVM（虚拟机）** 运行 Java 程序的工作环境。

> HotSpot 虚拟机 是 SunJDK 和 OpenJDK 中所带的虚拟机，也是目前使用范围最广的 Java 虚拟机。

---

## 执行流程

**Java是编译和解释并行的语言：**  

1. **源文件(.java)**经过编译器编译成为**字节码文件(.class)**：由虚拟机(JVM)逐行解释并执行。
 
2. 即时编译器(JIT)在编译时会识别反复执行的热点代码并保存机器码，复用时无需再逐行解释。

> 虚拟机的使用，赋予了字节码文件跨平台通用的特性：一次编译、到处运行。


*C/C++ 是编译语言，执行效率更高：*

*源文件(.c/cpp)经过编译器编译成为可执行文件(.exe)，可以直接在操作系统上执行。*


---

## 内存空间

Java 程序中内存分配和回收都由虚拟机(JVM)管理，不支持程序员直接对内存地址进行操作。

### 方法区 Method Area

存放 **Java 程序的二进制代码，包含类的信息**。

在虚拟机启动时直接存入系统内存中，因此方法区大小只受系统内存的限制。

> 进程是分配资源的基本单位。除方法区外，所有数据均存放在给进程分配的内存块中。

### 堆区 Heap

存放进程创建的**对象实例和数组**。

堆区内存空间由线程共享。在虚拟机启动时为进程创建，是占用内存最大的区域。

*JDK1.7 后 JVM 将常量池从方法区中移出，改为在堆中存放 **final 常量、static 变量和方法**。* 

### 栈区 Stack   

存放**线程和方法的参数、基础数据类型的局部变量和对象引用**，线程私有。

栈区内存空间由线程私有。线程每执行一个方法，都会在自己的虚拟机栈中创建一个栈帧，存放方法的相关信息。

- 虚拟机栈 为非虚拟机执行 java 方法服务
- 本地方法栈 为虚拟机自由地执行本地方法服务 

HotSpot 虚拟机中两者合二为一。

*线程私有的内存空间还存有程序计数器，用来记录线程的运行状态、管理线程的运行。*

## 特殊类型的内存分配

### String 类

String创建后对象一经赋值不再改变，作为静态数据会存放在常量池。

`String str1 = "str" + "ing";`

如果赋相同的值，引用会直接指向常量池中存在的原对象。

`String str2 = "string";`

但如果通过新建或拼接得到String对象，则会在堆内存空间创建一个新的对象。如果常量池中没有该字符串，也会在常量池中创建。

`String str3 = new String("str");`

`String str4 = str1 + str2;` 


### 常量池技术

对于包装类 Byte,Short,Integer,Long,Character,Boolean：默认创建了数值[-128，127] 的相应类型的缓存数据，用户使用时可以直接在常量池取用而不用新建对象。但是超出此范围仍然会去创建新的对象。

浮点数类型包装类 Float,Double 并没有实现常量池技术。


## 对象的内存分配
 
### 创建对象的流程

1. 检查类是否已被加载、解析和初始化，如果没有先加载类
2. 分配内存
3. 初始化内存空间
4. 设置对象头
5. 执行init方法，初始化对象

### 对象的内存分配方式

创建对象时，会把一块确定大小的内存从 Java 堆中划分出来分配给对象，有以下两种分配方式：

- **指针碰撞**：(内存规整无碎片时选用) 已使用内存和未使用内存用指针隔开，需要分配内存时将指针移动一定位置。
- **空闲列表**：(内存不规整时选用) 虚拟机维护一个列表记录空闲内存块，需要分配内存时选择合适的内存块。

*Java 堆内存是否规整，往往取决于垃圾收集算法：*
 
*是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。*


### 对象在内存中的布局

Hotspot 虚拟机中，对象在内存中分为 3 块区域：对象头、实例数据和对齐填充。

Hotspot 虚拟机的对象头包括：

- 对象运行数据（哈希码、GC 分代年龄、锁状态标志等）
- 类型指针，确定这个对象是那个类的实例。

*Hotspot 虚拟机要求对象起始地址必须是 8 字节整数倍，没有对齐时通过对齐填充来补全。*

---

## 垃圾回收

堆是垃圾收集器管理的主要区域。现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代。进一步划分的目的是更好地回收内存，或者更快地分配内存。

### 分区回收

垃圾收集器将堆内存分为新生代和老年代，这样我们就可以使用分代垃圾收集算法。

- 新生代 GC（Minor GC）:指发生新生代的的垃圾收集动作，垃圾回收非常频繁，回收速度也比较快。
+ 老年代 GC（Major GC/Full GC）:指发生在老年代的垃圾回收动作，回收速度明显更慢。


### 初次分配对象

新生代分为 eden 区和 survive 区， 其中 eden 区占用内存空间更大。

大多数情况下，对象在新生代 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

### 长期存活对象

虚拟机给每个对象设置一个年龄计数器。如果对象经过一次 Minor GC 后仍然能够存活，将从 eden 移动到 survive 空间中。对象每熬过一次 Minor GC，年龄就增加 1 岁。当它的年龄增加到一定程度（默认为 15 岁），就会晋升到老年代。

survive 区分为 from 区和 to 区两块大小相等的内存空间。Minor GC 执行时，会将 eden 区和 from 区中的存活对象复制到 to 区，清除 eden 区和 from 区内存。再把这些存活对象从 to 区移动回 from 区。

当老年代也没有足够空间进行分配时，虚拟机将发起一次 Major GC。

### 大对象

需要大量连续内存空间的对象（如字符串、数组）直接进入老年代，可以避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

