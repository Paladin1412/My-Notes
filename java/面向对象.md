# 面向对象

<br>

- **面向过程**：根据解决问题的过程，直接设计系统。如 C 语言。

- **面向对象**：将问题分解成多个对象，设计模块化、低耦合的系统。如 java 语言。

  - 特性：封装、继承、多态。

  - 优点：使系统更加灵活，易维护、易复用、易扩展。

---

## 封装

### 包 Package      

命名空间，表示 java 文件的存储路径。

#### 包的声明

`package NSTC.myproject.entity;` 

标明 java 文件在项目中的存储路径。

#### 包的导入

在 java 文件中如果需要使用其他类或者接口（非同一路径下），则需要进行导入：

1. 导入该类，但不包括类中的 static 变量和方法

`import java.io.InputStream;` 

2. 导入该路径下的所有类，但不包括路径下属文件夹内的类

`import java.io.*;`

3. 导入类中的 static 变量或方法

`import static java.lang.Math.PI;`

- 如果没有导入类，或者导入了同名类，在在调用时则需标明全路径: 

`java.io.InputStream in = new java.io.InputStream(System.in); `

---

> java 文件通常为一个 java 类 / 接口：
>
> 即使含有多个类 / 接口，也只能有一个 public 类 / 接口：且类名 / 接口名必须与文件名相同。

### 接口 Interface      

类的规范：只规定应含有哪些方法，而不负责具体实现。 

*JDK 1.8 以后，接口允许实现 static 和 default 方法。*

```java
public interface Contact {  
    // final 常量                
    static final int num_user; 
    // abstract 方法                   
    void call();
    // default 方法                                 
    default void chatOnline(int num) {      
        System.out.print("chat online with" + num);
    };                  
}
```

1. 声明接口：必须且默认为 static final，通常为 public 。
2. 只允许声明静态常量：必须且默认为 public static final 。
3. 声明抽象方法：必须且默认为 public abstract ，可以为 static。

#### 终态声明 final

- **final 常量**： 只能赋值一次，不可更改。
- **final 类**： 不可被继承。


#### 抽象声明 abstract

- **abstract 方法**：只有声明，而没有方法的具体实现。
- **abstract 类**：类的模板，不能实例化对象。必须由其他类继承才能使用。

```java
public abstract class ContactMachine {
    int number;
    public void call(int num){
        System.out.println("call" + num);
    }   
}
```

1. 接口不能实现方法，抽象类可以实现具体的方法，也可以不实现。
2. 接口只能定义静态变量，抽象类可以定义非静态变量。
3. 一个实体类可以实现多个接口，但只能继承一个抽象类。

#### 更新声明 default

- **default 方法**：更新接口时添加的新方法，允许旧类实现接口而不实现该方法。
  
  - 可以直接在接口内实现，供没有定义的旧类直接使用。若类中实现了该方法则覆盖。

  - 如果类实现了多个接口且拥有同名 default 方法：

     1. 两个接口若存在继承关系，调用时优先使用子类方法。
     2. 否则，必须重写子类 default 方法明确实现哪个接口：

```java
class Computer implements Contact, PlayGame {
    void chatOnline(int num){
        Contact.super.chatOnline(int num);     
    }
}
```

---

### 类 Class 

对象的类型：定义含有的变量和方法。

```java
public class Telephone {     
    // 变量
    int number;                  
    // static 变量 
    static num_total_phone;  
    // 构造方法
    public Telephone(int num){        
        number = num;
    } 
    // 方法  
    public void call(int num){            
        System.out.println(this.number + "call" + num);
    }
    // static 方法
    void static showNum(){            
        System.out.println(num_total_phone);
    }
    // 初始化块
    {       
        num_total_phone++;                                      
    }
    // static 初始化块
    static{                                                              
         num_total_phone = 0;
    }
}
```
- 变量：对象中存储的数据
- 方法：调用时执行的代码
- 初始化块：创建对象前自动执行的代码

#### 构造方法

在创建对象时自动执行，不返回任何参数（先执行初始化块，再执行构造方法）。

未定义任何构造方法时，系统会自动添加无参构造方法。

#### 静态声明 static

类的公用属性。

- **static 变量**：该变量由该类的所有对象共享，不需要创建对象也可使用。
- **static 方法**：允许直接访问，不需要创建对象也可被调用。如 main 方法。
- **static 初始化块**：在创建类的第一个对象前自动执行（先执行静态初始化块，再执行初始化块）。


#### 访问权限声明 public / protected / private

接口/类/变量/方法是否允许被其他文件访问：

- **public**： 允许所有访问。
- **protected**： 只允许本类、同包和子类访问。
- **[default]**： 允许本类和同包访问。
- **private**： 只允许本类访问。

---

### 对象 Object

类的实例化，提供给用户使用。

**创建对象**

`Telephone myphone = new Telephone(13937639697);`               

**修改对象变量**

`myphone.number = 15991633459;`                                      

**执行对象方法**

`myphone.call(15837619756);`                                         

---


### 内部类 inner class

定义在类中,内部类可以使用外部类所有属性和方法。若定义在方法内则只在方法内可见。

```java
public class Telephone{                          
    ……
    public class Memory{    
        String data;
        void store(String message){
            data = message;
        }
    }
}
```

创建内部对象

`Memory myphone_memory =  myphone.new Memory();` 
 

**匿名内部类**

`Thread thread = new Thread(new Runnable(){...});`

---

### 方法

**值传递**：在 Java 方法中传递参数，形参本质是实参的副本。

1. 参数是基础数据类型：对形参的改变不会影响实参。
   
2. 参数是指向对象的引用（包括数组、字符串）：对对象数据进行更改会影响实参，但改变引用指向的对象不会影响实参。

---

## 继承

### 类的继承 C-extends

```java
final public class Smartphone extends Telephone{  
    // 扩展变量               
    final String cpu;  
    // 扩展方法              
    private void useapp(){
        System.out.println("Use APP");
    }
    // 子类构造方法
    public Smartphone(int number, String cpu){    
        super(number);        
        this.cpu = cpu;                          
    }
    // 重写方法
    @Override         
    void call(int num){
        super.call();                            
        System.out.println("By the Internet"); 
    }
}
```

创建子类对象

`Smartphone myphone = new Smartphone(); `    

- 父类的**属性值**不会被子类继承，但子类可以通过父类提供的方法得到父类的属性值。
- 父类的 **static 方法**不会被子类继承，子类的 static 方法会隐藏父类的同名 static 方法。
- 父类的**构造方法**不会被子类继承，子类必须在构造方法首行调用父类构造方法（先构造父类，再构造子类）。

---

### 接口继承 I-extends
   
```java
interface OnlineGame extends Contact, Game{  
    static int num_user; 
    public abstract void playgame();
    public abstract void call(int num);     
}
```
<font color=green>Java 类只能单继承，但 Java 接口可以多继承。（C++允许类的多继承）</font>

### 接口实现 implements
   
```java
public class PSP implements Game{             
   public void playgame(){    
       System.out.println("PlayGame");        
    }
}
```

---

## 多态

### 重载和重写

- **重载**(overload)：定义多种同名方法，调用时根据传入参数判定调用哪种方法。
- **重写**(overwrite)：子类定义完全相同的方法覆盖父类。
  
### 继承多态

`Telephone myphone1 = new Smartphone(15991633459);`

- 允许子类给父类对象赋值

~~`Smartphone myphone2 = new Telephone(15837619756);`~~     

- 不允许父类给子类对象赋值

### 方法多态

`myphone1.call(120);`  

- 普通方法根据实际对象类型来判定使用谁的方法：执行子类 SmartPhone 重写的方法

`myphone1.showNum();`

- static 方法、private 方法、final 方法以及构造方法不能被覆盖：执行父类 TelePhone 的方法
