# 数据类型

---

## 基本数据类型

Java语言提供了八种基本类型，均继承自 Number 抽象类。用户无需定义，可以直接使用。


基本数据类型|位数|默认值|包装数据类型|备注
 -| - | - | - | -
byte|8|0|Byte
short|16|0|	Short
int|	32|	0|Integer
long|64|0|	Long
float|	32|	0.0	|Float|数字后加f
double|	64|	0.0|Double
char|	16|	null|Character|必须用单引号
boolean	|1|	false|	Boolean


## 包装数据类型

- **基本数据类型**（如int），是一个值。允许不赋初值，系统自动添加默认值。
- **包装数据类型**（如Integer），是一个对象。实例化必须赋初值，且赋值后不能改变。

```java
class Integer{
    final int value;    
}
```

包装数据类型主要用于集合框架中的元素。

---

## 数组

本质是一个对象，引用指向存储数组首个元素的地址（堆区）。创建时必须确定数组长度和类型。

**创建数组**

1. `int[] arr = new int[4];`

2. `int[] arr = {1,2,3,4};`

3. `int[] arr = new int[]{1,2,3,4};`


Arrays.sort(arr1);

---

## 字符串

### String 类         

String 类本质是一个对象，引用指向存储字符串对象的地址（方法区）。引用可变，但内存数据不能被更改。

**创建字符串**

1. `String s1 = "hello";`
2. `String s1 = new String("hello");`

- `String s2 = "hello";`  s2 指向 s1 的字符串对象（引用指向的内存地址相等）
- `String s3 = new String("hello");`  s3 在堆区新建字符串对象（引用指向的内存地址不等）

**变更字符串**

- `s1 = "goodbye";`  s1 指向新的字符串对象（引用指向的内存地址改变）



### StringBuilder / StringBuffer 类

由于 String 类不可变性，对其频繁更改往往会产生较多临时变量类，占用大量内存。对此我们通常使用 StringBuilder/StringBuffer 来避免，这两个类允许在原有内存地址对字符串进行操作。


<font color = 'brown'>StringBuilder 性能更好，StringBuffer 线程安全。</font >


**创建字符串**

 

`StringBuffer str = new StringBuffer("hello");`

- 字符串默认长度为16，超出后会进行自动扩容。
       
- 不可以以直接赋值的形式创建：~~`StringBuffer str = "hello";`~~  



**String 类常用方法**

```java
str.length();            // (int)返回字符串长度

str.split(":");          // (String[])分解字符串

str.contains(str1);      // (boolean)判断是否存在子字符串
str.indexOf(str2);       // (int)查找子字符串出现的第一个位置，没有返回-1
str.lastIndexOf(str3);   // (int)查找子字符串出现的最后一个位置，没有返回-1

str.trim();              // (String)去掉字符串左右空格　　
str.substring(0,3);      // (String)截取子字符串
str.replace("a", "b");   // (String)新字符替换旧字符

// StringBuilder / StringBuffer 类专用

str.toString();          // (String)转化为 String 类

str.append("add");       // 末尾添加字符串

str.insert(0,"insert");  // 指定位置插入字符串

str.deleteCharAt(6);     // 指定位置删除字符
str.delete(6,8);         // 指定位置删除字符串
```

**数据类型转换**

```java
// Number > String

String s1 = data.toString();           // data 必须为包装数据类型
String s2 = Integer.toString(data);    // data 可以为基础数据类型，包括字符数组 char[]
String s3 = String.valueof(data);      // data 可以为基础数据类型，包括字符数组 char[]

// String > char

char c = str.charAt(0);
char[] ch = str.toCharArray();

// String > int

int n1 = Integer.parseInt(str);          
int n2 = Integer.valueof(str);
```

---

## Equals 方法 和 ==

1. 对于基本数据类型，两者等价：判断数据是否相等。
   
2. 对于对象（如 String 类）：

  - **==**：比较两个元素内存地址是否相等，即是否是同一个元素
  - **Equals 方法**：比较两个元素内容是否一致

`s1 == s2;`     判断两个引用指向的内存地址是否相等  

`s1.equals(s2);`             判断两个引用指向的元素是否一致（s1为空会出现空指针异常,s2为空返回false）

`Objects.equals(s1,s2);`     判断两个引用指向的元素是否一致（推荐）

### 重写 Equals 方法

对于用户自定义类，正常使用 equals 方法需要进行重写。

```java
public class User{
    int ID;
    String name;

    ......

    @Override
    public String toString() {
        return this.id + " " + this.name + " " + this.age;
    }

    @Override
    public boolean equals(Object obj) {
        if(this == obj)  return true;

        if(obj == null) return false;

        if(obj instanceof User){
            User other = (User) obj;
            if(equals(this.ID, other.ID) && equals(this.name, other.name)){
                return true;
            }
        }
        
        return false;
    }

    @Override
    public int hashCode() {
        int result = 17;
        result = 31 * result + (ID == null ? 0 : ID.hashCode());
        result = 31 * result + (name == null ? 0 : name.hashCode());
        return result;
    }
}

```

重写 equals 方法必须重写 hashcode 方法：以保证相同对象拥有相同的哈希地址。

这样才能正常地把该类对象放入 HashSet/HashMap 等集合框架中查找。

---

## 泛型

定义类时不固定数据类型，等到创建对象或调用方法时再明确的特殊的类型。编译时检查类型安全，自动隐性地进行强制转换。


可使用 A-Z 之间的任何一个字母，常用：
        
 - T (type)： 表示具体的一个 java 类型
 - K V (key value)： 分别代表java键值中的 Key Value
 - E (element)： 代表 java 集合框架元素
 - ？：表示不确定的 java 类

```java
// 定义
public class Box<T> {
    private T t;
    public void set(T t) {
        this.t = t;
    }
    public T get() {
        return t;
    }
} 

// 调用
class Test{
    static void main(String[] args){
        Box<Integer> myBox = new Box<>();
        myBox.set(3);
        System.out.print(myBox.get());
    }
}
```