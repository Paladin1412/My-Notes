# 线程并发

---

## 基本概念

### 并行和并发

- **并行**：多个CPU核心同时工作，处理不同的任务。

- **并发**：多个任务交替使用CPU核心工作，以提高CPU利用率。

### 进程 processor

程序的一次执行。由操作系统创建并分配资源，执行一个单独的任务。

系统进行资源分配和调度的独立单位，每一个进程都有它自己的内存空间和系统资源。

> Windows系统中，每个运行的 Java 程序都是一个独立的进程。

### 线程 thread 

进程内的执行单元，不分配单独的资源，执行一个单独的子任务。

进程内调度和分派的基本单位，共享进程资源。

> 运行的 Java 程序内含至少一个主线程 main ，用户可以在 Java 程序中自定义并调用多个线程。 JVM 垃圾回收线程也是一个独立的线程。


### 线程运行状态

1. 运行(Running): CPU正在执行线程。
2. 就绪(Runnable): 线程等待CPU执行。                  
3. 阻塞(Blocked): 线程缺少其他硬件资源，获得资源后进入就绪状态。    
4. 等待(Waitting): 线程接受了等待指令，超时/由指令唤醒后进入就绪状态。  

> 线程在 运行态/就绪态 之间的调度由 JVM 自动负责，采用分优先级多队列时间片轮转算法。CPU正在执行哪个线程对用开发者不可见。


### Thread 类

系统自带的线程类，实现了 Runnable 接口。

## 线程的使用

### 定义线程

1. 继承 Thread 类，重写run方法
   
```java
public class MyThread extends Thread {
   @Override
   public void run() {
       //run方法内自定义线程功能
   }
}
```

2. 实现 Runnable 接口，重写run方法（推荐）

```java
public class MyThread implements Runnable {
    @Override
    public void run() {
        //run方法内自定义线程功能
    }
}
```

**run方法**

`thread.run();`

运行时线程执行的功能：开发者一般只负责定义，由 JVM 自动调用并执行。

如果开发者调用该方法，只会当作普通方法执行一次。

### 调用线程

```java
public class Main {
   public static void main(String[] args) {
       MyThread mythread = new MyThread();
       Thread t1 = new Thread(mythread);
       Thread t2 = new Thread(mythread);
       t1.start();
       t2.start();
   }
}
```

**Thread类构造方法**

`Thread t=new Thread(new Runnable(){});`

系统会自动添加线程名Thread-X，用户也可以指定线程名： 

`Thread thread = new Thread(new Runnable(){}, "ThreadName");`

**start方法**

`thread.start();`

启动线程,进入就绪状态：JVM会自动对线程进行调度，在运行时执行线程的run方法。


```java
//开发者也可以直接在主程序中定义线程功能
public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable(){
            public void run(){
                System.out.println(Thread.currentThread().getName());
            }
        } ).start();
    }
}
```





### 线程切换

<font size = 3 color=brown>从属于Thread类：</font>

**yield方法**

`Thread.yield();`

当前线程从运行状态让出控制权，进入就绪状态。

**sleep方法**

`Thread.sleep(1000);`

当前线程停止运行，进入计时等待状态（保持对象锁，其他线程不可访问其资源）。

如果方法在线程类内，可直接写成：`sleep(1000);`

<font size = 3 color=brown>从属于Object类：</font>

**wait方法**

`wait();`

当前线程停止运行，进入等待状态（释放对象锁，其他线程可访问其资源）。

可以设定为计时等待： `wait(1000); ` 

可以停止运行指定线程： `thread2.wait(1000);`  



       

必须在同步环境下(synchronized)使用，否则会抛出`IllegalMonitorStateException`。

**notify方法**

`notify();`                

当前线程从等待状态唤醒，进入就绪状态。

可以唤醒指定线程： `thread2.notify();`          

可以同时唤醒所有线程 `notifyall();`      

必须在同步环境下(synchronized)使用，否则将抛出`IllegalMonitorStateException`。

**join方法**

`thread2.join(); `

当前线程停止运行，进入等待状态直到线程thread2终止。通常用于主线程main。

**interrupt方法**

`thread2.interrupt();`     

对线程thread2设置中断标志，让该线程自行终止。用户需自定义线程终止方法。

`thread2.isInterrupted();` 查看线程中断标志
`thread2.interrupted();` 查看线程中断标志然后将其置为false
```java
//自定义线程终止方法
public class MyThread extends Thread {
    @Override
    public  void run() {
        while (true) {
            System.out.print("hello");
            //检测中断标志并结束循环
            if(this.isInterrupted()){
                break;
            }
        }
    }
}
```

阻塞/等待线程一旦调用interrupt()方法会立即退出阻塞/等待，并抛出`InterruptedException`.

需要捕获异常，常用捕获异常的方式使其立即退出等待状态(wait/sleep/join)：

```java
public class MyThread extends Thread {
    @Override
    public  void run() {
        try {
            sleep(100000);
        } catch (InterruptedException e) {
            return;
        }
    }
}
```

---

## 加锁机制

### 线程安全

线程是交替执行的，如果多个线程同时对共享变量进行组合操作，可能会出现问题（破化了事务的原子性）。

更新丢失、读脏数据、不可重读。

解决方法：**加锁**（一次只允许一个冲突线程进入被锁住的代码块）

**死锁**
加锁后，多个线程各自占有一些资源，又缺少其他线程占有的资源，导致均无法顺利运行。


### 锁的性质

**悲观锁**

每次获取资源时都会给资源上锁，其他线程想获取该资源时会被阻塞，直到其释放锁。

悲观锁适合多写的应用场景，java中synchronized和ReentrantLock等独占锁都是悲观锁。

**乐观锁**

读资源时不会给资源上锁，多个线程可以同时读取该资源。
写资源时会（更新版本号）并检查在此期间其他线程有没有写过该资源（比对版本号），如果版本号不对说明被其他资源写过，写资源被驳回。

乐观锁适用于多读的应用类型，这样可以提高吞吐量。一般会使用版本号机制或CAS算法实现。

**可重入锁**

一个线程允许多次对同一对象上锁。对于每一个对象来说，java虚拟机维护一个计数器，记录对象被加了多少次锁,当计数器跳到0的时候，锁就被完全释放。 

java中synchronized和ReentrantLock等都是可重入锁。

### Synchronized锁

修饰代码块或方法（包含静态方法），同一时刻只允许一个线程访问。

方法/代码块执行完毕后会自动释放锁。当线程执行的代码出现异常时，也会自动释放所有锁。

<font size = 2 color=brown>synchronized 关键字加到静态方法和代码块上都是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。</font>



```java
//双重锁结构实现单例模式
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
            if (singleton == null) {  
                singleton = new Singleton();  
            }  
        }  
    }  
    return singleton;  
    }  
}
```
### ReenTrantLock锁

性能上两者没有明显差异，但有以下区别：

Synchronized 是在 JVM 层面实现的。而 ReenTrantLock 是在 JDK 层面实现的，需要手动 lock() 和 unlock 方法配合 try/finally 语句块来完成。（所以使用 Synchronized 会更方便）

ReenTrantLock 比 Synchronized 增加了一些高级功能，主要有以下三点：
1. 等待可中断；
2. 可实现公平锁（先等待的线程先获取锁）；
3. 可实现选择性通知（锁可以绑定多个条件）。


---

## 线程池

https://www.jianshu.com/p/7ab4ae9443b9

线程池本质上是一种对象池，用于管理线程资源。在任务执行前，需要从线程池中拿出线程来执行。在任务执行完成之后，把线程放回线程池。实际开发中，线程资源一般通过线程池提供：
 
1. 线程的创建更加规范，可以合理控制开辟线程的数量；
2. 不必频繁地创建和销毁线程，优化了资源的开销。

### 基本概念

**线程池的主要处理流程**

1. 判断核心线程池是否已满，如果不是，则创建线程执行任务
2. 如果核心线程池满了，判断队列是否满了，如果队列没满，将任务放在队列中
3. 如果队列满了，则判断线程池是否已满，如果没满，创建线程执行任务
4. 如果线程池也满了，则按照拒绝策略对任务进行处理

**核心线程池**：最多能同时处理的线程数（超出数目则排队等待）
**最大线程池**：最多能同时创建的线程数（超出数目则拒绝）

常见的使用场景：处理数据库连接，接收网络请求。


### Executors类

线程池工厂，提供4种工厂方法创建线程池：

newSingleThreadExecutor 单个线程的线程池，串行执行任务
newFixedThreadExecutor(n) 固定数量的线程池，达到最大数量进入等待队列排队
newCacheThreadExecutor 可缓存线程池，会自动回收空闲线程
newScheduleThreadExecutor 大小无限制的线程池，可定时执行任务

```java
public class ThreadPoolTest {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 10; i++) {
            executor.submit(() -> {
                System.out.println("thread id is: " + Thread.currentThread().getId());
                try {
                    Thread.sleep(1000L);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
```

### ThreadPoolExecutor类

Executor框架虽然提供了创建线程池的方法，但不够灵活（当创建的线程过多有危险）；而其方法内部也是通过ThreadPoolExecutor方式实现的，创建符合自己的业务场景需要的线程池,一般使用ThreadPoolExecutor类。


**构造方法**
```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {...}
```

corePoolSize: 核心线程池大小

maximumPoolSize: 最大线程池大小

keepAliveTime: 不被执行的线程会在多长时间后被销毁

unit: keepAliveTime的单位(TimeUnit.SECOND)

workQueue: 任务队列

threadFactory:线程工厂接口，用于创建线程，一般用默认

handler: 拒绝策略


时间单位
TimeUnit.DAYS;               //天
TimeUnit.HOURS;             //小时
TimeUnit.MINUTES;           //分钟
TimeUnit.SECONDS;           //秒
TimeUnit.MILLISECONDS;      //毫秒


任务队列可选
ArrayBlockingQueue，基于数组实现的阻塞队列（有界）
LinkedBlockingQueue，基于链表实现的阻塞队列（可以无界）
SynchronousQueue，不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作
PriorityBlockingQueue，带优先级的无界阻塞队列

拒绝策略
CallerRunsPolicy // 在调用者线程执行
AbortPolicy // 直接抛出RejectedExecutionException异常
DiscardPolicy // 任务直接丢弃，不做任何处理(常用)
DiscardOldestPolicy // 丢弃队列里最旧的那个任务，再尝试执行当前任务

可以重写的方法，ThreadPoolExecutor中为空实现
protected void beforeExecute(Thread t, Runnable r) // 任务执行前被调用
protected void afterExecute(Runnable r, Throwable t) // 任务执行后被调用
protected void terminated() // 线程池结束后被调用


**提交任务**

可以向线程池提交的任务有两种：Runnable和Callable，
Callable作为Runnable的一种补充，允许有返回值，允许抛出异常。

execute()用于提交不需要返回结果的任务。

submit()用于提交一个需要返回结果的任务。该方法返回一个Future对象，通过调用这个对象的get()方法获得。get()方法会一直阻塞，直到返回结果返回。

**关闭线程池**

shutdown()会将线程池状态置为SHUTDOWN，不再接受新的任务，等待线程池中已有的任务执行完成再结束。

shutdownNow()会将线程池状态置为SHUTDOWN，对所有线程执行interrupt()操作，清空队列，并将队列中的任务返回。

isShutdown()和isTerminated，分别表示是否关闭和是否终止。

**ThreadPoolExecutor自带了一些方法。**

getTaskCount()，获取已经执行或正在执行的任务数
getCompletedTaskCount()，获取已经执行的任务数
getLargestPoolSize()，获取线程池曾经创建过的最大线程数，根据这个参数，我们可以知道线程池是否满过
getPoolSize()，获取线程池线程数
getActiveCount()，获取活跃线程数（正在执行任务的线程数）



```java
public class ThreadPoolTest {
    public static void main(String[] args) {
        ExecutorService executor = new ThreadPoolExecutor(1, 1, 1, TimeUnit.SECONDS, new ArrayBlockingQueue<>(1)) {
            @Override protected void beforeExecute(Thread t, Runnable r) {
                System.out.println("beforeExecute is called");
            }
            @Override protected void afterExecute(Runnable r, Throwable t) {
                System.out.println("afterExecute is called");
            }
            @Override protected void terminated() {
                System.out.println("terminated is called");
            }
        };

        executor.submit(() -> System.out.println("this is a task"));
        executor.shutdown();
    }
}
```



