# 异常处理

---


## Throwable 接口

### Error 类

【错误】如虚拟机错误，线程死锁。无法被处理，出现时会导致程序无法正常执行并强制退出。

### Exception 类

#### Checked Exception

  【可检查异常】如IO异常，SQL异常等大部分异常，或者自定义异常。出现时必须捕获或抛出，否则编译不会通过。

#### Runtime Exception
   
  【运行时异常】主要为空指针异常，越界异常，除数为0的算数异常等。出现时应当找出错误并修改程序。

*Java 规定，Runtime Exception 将在 Java 运行时由系统自动抛出，允许应用程序不进行处理。*

## 异常处理

### 抛出异常 throw

当方法执行出现问题时，方法会创建异常对象并抛出，异常对象中包含异常类型和异常信息。

- **throw**：发现问题，创建异常对象并抛出，等待程序进行异常处理。

- **throws**：声明方法可能抛出某种异常且未经处理，调用该方法的上级需要进行异常处理。

### 捕获异常 catch

当方法执行抛出异常时，转而由专门的代码块对异常进行处理。

- **try**：可能出现异常的代码块。

- **catch**：捕获相应异常后停止执行 try 代码，转而执行对应 catch 代码。如果没有异常 catch 代码不会执行。

- **finally**：无论是否发生异常，finally 代码总会被执行。一般用于释放资源。

*Java 7 后在 try 语句中打开 IO 流，会在跳出后自动关闭流。不必再用 finally 语句关闭。*

> try/catch 代码中的 return 语句会在执行完 finally 后再返回。
> finally 代码中应避免含有 return 语句或抛出异常，否则只执行 finally 中的 return 语句，且不会向上级抛出异常。</font>

```java
//抛出异常但不处理
class TestException{            
    public void writeList(int size) throws IndexOutOfBoundsException, IOException{
        PrintWriter out = null;
        if(size < 1) throw new IndexOutOfBoundsException("至少要输出1个字符");
        try{
            out = new PrintWriter(new FileWriter(txt));
            for (int i = 0; i < size; i++)
                System.out.println("Value at: " + i + " = " + list.get(i));
        }finally{
            if (out != null) out.close();
        }
     }
}
```

如果 try 语句中出现的异常未被 catch，默认将异常 throw 给上层调用者处理（必须在方法中声明 throws）。


```java
//抛出异常并处理
class TestException{               
    public void writeList(int size) {
        PrintWriter out = null;
        try {
            if(size < 1) throw new IndexOutOfBoundsException("至少要输出1个字符");
            out = new PrintWriter(new FileWriter("OutFile.txt"));
            for (int i = 0; i < size; i++)
                System.out.println("Value at: " + i + " = " + list.get(i));
        } catch (IndexOutOfBoundsException e) {
            System.err.println("Caught IndexOutOfBoundsException: " + e.getMessage());
        } catch (IOException e) {
            System.err.println("Caught IOException: " + e.getMessage());
        } finally {
            if (out != null) out.close();
        }
    }
}
```

## 自定义异常

```java
//自定义异常
class MyException extends Exception {
    public MyException() {
        super();
    }
    public MyException(String message) {
        super(message);
    } 
}
```


## 异常转译

当 Sevice/DAO 层出现如 SQLException 异常时，程序一般不会把底层的异常传到 controller 层。

程序往往会捕获原始异常，然后再抛出一个新的业务异常（即在catch语句中throw新的异常）。

**异常处理类**

在 Spring Boot 中，所有异常统一由专门的异常处理类`@ControllerAdvice`处理。

```java
//控制器异常处理类
@ControllerAdvice 
public class ErrorHandler {
    
    private static final org.slf4j.Logger log = LoggerFactory.getLogger(ErrorHandler.class);
    
    //输入参数校验异常
    @ExceptionHandler(value = MethodArgumentNotValidException.class)
    public ResponseEntity<Result> NotValidExceptionHandler(HttpServletRequest req, MethodArgumentNotValidException e) throws Exception {
        
        log.debug("异常详情", e);
        BindingResult bindingResult = e.getBindingResult();
        
        //rfc4918 - 11.2. 422: Unprocessable Entity          
        Result res = MiscUtil.getValidateError(bindingResult);
        return new ResponseEntity<Result>(res, HttpStatus.UNPROCESSABLE_ENTITY);
    }
    
    //404异常处理
    @ExceptionHandler(value = NoHandlerFoundException.class)
    public ResponseEntity<Result> NoHandlerFoundExceptionHandler(HttpServletRequest req, Exception e) throws Exception {
        
        log.debug("异常详情", e);
                
        Result res = new Result(404, "页面不存在");
        return new ResponseEntity<Result>(res, HttpStatus.NOT_FOUND);
    }
    
    //其他默认异常处理
    @ExceptionHandler(value = Throwable.class)
    public ResponseEntity<Result> defaultHandler(HttpServletRequest req, Exception e) throws Exception {
                
        Result res = new Result(500, "服务器内部错误");
        log.debug("异常详情", e);
        
        return new ResponseEntity<Result>(res, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

