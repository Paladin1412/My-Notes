# 线程安全

## AQS 框架

AbstractQueuedSynchronizer 类，位于 java.util.concurrent.locks 包内。用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore 等。

- 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。
- 如果被请求的共享资源被占用，就将暂时获取不到锁的线程封装成一个结点，加入到一个虚拟的双向队列 CLH 中。

![CLH](img/CLH.png)

## ReentrantReadWriteLock 锁

JAVA的并发包提供了读写锁ReentrantReadWriteLock，其拥有两个锁：读锁-共享锁；写锁-排他锁。如果其他线程没有持有写锁，线程就能获得读锁。而只有其他线程没有持有任何锁，线程才能获得写锁。这样在没有写操作的时候，允许多个线程同时读一个资源，提高并发效率。

一个线程要想同时持有写锁和读锁，必须先获取写锁再获取读锁；写锁可以降级为读锁；读锁不能升级为写锁。


## Semaphore 信号量

Semaphore 类是一个同步工具类，需要进行导入：`import java.util.concurrent.Semaphore`。

synchronized 和 ReentrantLock 一次只允许一个线程访问某个资源，如果指定多个线程同时访问某个资源需要钱使用 Semaphore 类。线程执行时调用 acquire 方法申请信号量，如果剩余信号量不足则必须等待其他线程执行完毕后调用 release 方法释放信号量。

**Semaphore 方法**

```java
Semaphore semaphore = new Semaphore(0);       
Semaphore semaphore = new Semaphore(20, true);  

// Semaphore 构造方法设定了初始信号量，可以为 0。默认为非公平锁，设定属性 true 则为公平锁。

semaphore.acquire();              // 线程获取一个信号量
semaphore.acquire(5);             // 线程获取五个信号量

semaphore.release();              // 线程释放一个信号量
semaphore.release(5);             // 线程释放五个信号量
```

**Semaphore 示例**

```java
public class SemaphoreExample1 {

  public static void main(String[] args) throws InterruptedException {
    ExecutorService threadPool = Executors.newFixedThreadPool(300);
    // 设置 20 个信号量
    final Semaphore semaphore = new Semaphore(20);
    // final Semaphore semaphore = new Semaphore(20, true);  公平锁

    for (int i = 0; i < 500; i++) {
      final int threadnum = i;
      threadPool.execute(() -> {
        try {
          semaphore.acquire();             // 获取一个信号量
          test(threadnum);
          semaphore.release();             // 释放一个信号量
        } catch (InterruptedException e) {
          e.printStackTrace();
        }

      });
    }
    threadPool.shutdown();
    System.out.println("finish");
  }

  public static void test(int threadnum) throws InterruptedException {
    Thread.sleep(1000);
    System.out.println("threadnum:" + threadnum);
    Thread.sleep(1000);
  }
}
```

---

## CountDownLatch 倒计时器

CountDownLatch 类是一个同步工具类，需要进行导入：`import java.util.concurrent.CountDownLatch`。

其通过 await 方法设置一个屏障，线程到达后被阻塞。直到其他线程调用 countDown 方法达到 N 次后才允许向后执行。 CountDownLatch 类是一次性的，计数器值只能在构造方法中初始化一次，不能被重复使用。常用来协同多个线程之间的执行顺序，比如主线程需要等待多个组件加载完毕之后再继续执行。

**CountDownLatch 方法**

```java
CountDownLatch latch = new CountDownLatch(5);

// CountDownLatch 构造方法设定了门闩个数。

latch.countDown();                // 解锁门闩，门闩个数减一
latch.await();                    // 线程等待门闩，个数为 0 后向后执行
```

**CountDownLatch 示例**

```java
import java.util.concurrent.CountDownLatch;

public class ThreadDemo {

    final static CountDownLatch latch = new CountDownLatch(5);

    public static void main(String[] args) throws InterruptedException {
        for(int i = 0; i < 5; i++) {
            new MyThread().start();
        }
        latch.await();
        System.out.println("主线程继续执行");
    }

    static class MyThread extends Thread {
        @Override
        public void run() {
            try {
                System.out.println(getName() + "打开门闩");
            } finally {
                latch.countDown();
            }
        }
    }
}
```

---

## CyclicBarrier 循环栅栏

CyclicBarrier 类也是一个同步工具类，需要进行导入：`import java.util.concurrent.CyclicBarrier`。

其通过 await 方法设置一个屏障，线程到达后被阻塞。只有当 N 个线程都到达屏障后才允许这些线程向后执行。和 CountDownLatch 不同，CyclicBarrier 可循环利用。常用于多线程计算数据，最后合并计算结果的场景。

**CyclicBarrier 方法**

```java
CyclicBarrier barrier = CyclicBarrier(10); 
CyclicBarrier barrier = CyclicBarrier(10, ()-> System.out.println("open"));

// CyclicBarrier 构造方法设定了参与线程的个数 N，也可以选择设定在第 N 个线程到达屏障时执行方法。

barrier.await();                             // 线程必须等到 N 个线程才能向后执行
barrier.await(20, TimeUnit.SECONDS);         // 线程等待规定时间后无论如何都会向后执行
```

**CyclicBarrier 示例**

```java
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo {  
    public static void main(String[] args) {  
        for(int i = 0; i < 10; i++) {
            new MyThread().start();
        }
    } 
}

class MyThread extends Thread {
    static CyclicBarrier barrier = new CyclicBarrier(5, new Runnable() {
        @Override
        public void run() {
            System.out.println("栅栏开启");
        }
    });
        
    @Override
    public void run() {
        try {
            Thread.sleep(1000);
            System.out.println(getName() + " 到达栅栏");
            barrier.await();
            System.out.println(getName() + " 冲破栅栏");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

